#include "data.h"


CData::CData()
{
    modificationCounter = 0;

    aquifer.storativity = 0.;
    aquifer.transmissivity = 0.;

    domain.length[0] = 0.;
    domain.length[1] = 0.;
    domain.resolution[0] = 0.;
    domain.resolution[1] = 0.;

    timing.end = 0.;
    timing.numberOfIntervals = 0;

    outputs.clear();
    wells.clear();
    pumpseries_vec.clear();
}

CData::~CData()
{}

//////////////////////////////////////////////////////////////////////////////
/// \brief CData::readData
/// \param inputFile: path and name
///
/// !!!!! restriction on output instances generated by keyword #output:
/// there is a convention in the output and view pages of the wizard
/// exactly 2 output instances must be generated in this order:
/// 1. snaphots: distributionType 0
/// 2. timeseries: distributionType 1
/// timingType must be 0 always (output for all time steps)
/// the ConePlusPlus simulator itself supports more output types
///
void CData::readData(QString inputFile, bool inputReadFlag)
{
  QFile file(inputFile);
  if(!file.open(QIODevice::ReadOnly))
    QMessageBox::information(0,"error","No file " + inputFile);
  else
  {
    int numberOfNodes;
    QTextStream in (&file);
    QString valueString ;
    QStringList fields;
    wells.clear();
    outputs.clear();

    for (;;)
    {
      valueString = in.readLine();
      fields = valueString.split(" ");

      if(fields[0] == "#end")
        break;
      //////////
      if(fields[0] == "#aquifer")
      {
        valueString = in.readLine();
        fields = valueString.split(" ");
        aquifer.transmissivity =  QString(fields[0]).toDouble();
        aquifer.storativity = QString(fields[1]).toDouble();
      }
      //////////
      if(fields[0] == "#domain")
      {
        valueString = in.readLine();
        fields = valueString.split(" ");
        domain.length[0] =  QString(fields[0]).toDouble();
        domain.length[1] =  QString(fields[1]).toDouble();
        domain.resolution[0] =  QString(fields[2]).toDouble();
        domain.resolution[1] =  QString(fields[3]).toDouble();
      }
      //////////
      if(fields[0] == "#well")
      {
        valueString = in.readLine();
        fields = valueString.split(" ");
        wellData well_inst;
        well_inst.location[0] = QString(fields[0]).toDouble();
        well_inst.location[1] = QString(fields[1]).toDouble();
        well_inst.pumpingRate = QString(fields[2]).toDouble();
        well_inst.pumpseriesName = fields[3];

        wells.push_back(well_inst);
      }
      //////////
      if(fields[0] == "#timing")
      {
        if(fields[1] == "intervals")
        {
          valueString = in.readLine();
          fields = valueString.split(" ");
          timing.numberOfIntervals = QString(fields[0]).toInt();
          timing.end = QString(fields[1]).toDouble();
        }
      }
      ////////// mind restriction mentioned above
      if(fields[0] == "#output")
      {
        outputData output_inst;
        valueString = in.readLine();
        fields = valueString.split(" ");
        output_inst.outfileName = fields[0];
        /// distribution type
        valueString = in.readLine();  // domain or selected
        fields = valueString.split(" ");
        if(fields[0] == "domain")
        {
            output_inst.outputDistributionType = 0;
            if (outputs.size() != 0)
                 QMessageBox::information(0, "error", "Distribution type domain is"
                                                      "for 1st output instance");
        }
        else if(fields[0] == "selected")
        {
            output_inst.outputDistributionType = 1;
            if (outputs.size() != 1)
                 QMessageBox::information(0, "error", "Distribution type selected is"
                                                      "for 2nd output instance");
            valueString = in.readLine();
            fields = valueString.split(" ");       
            numberOfNodes = QString(fields[0]).toInt();
            for (int i = 0; i < numberOfNodes; i++)
            {
               outputNode node_inst;
               valueString = in.readLine();
               fields = valueString.split(" ");
               node_inst.x = QString(fields[0]).toDouble();
               node_inst.y = QString(fields[1]).toDouble();
               output_inst.outputNodes.push_back(node_inst);
            }
        }
        else
        {
          QMessageBox::information(0, "error", "Output distribution type '" +  fields[0] + "' not supported");
        }
        /// timing type
        valueString = in.readLine(); // only timing type
        fields = valueString.split(" ");

        if(fields[0] == "times")
        {
          if(fields[1] == "all")
          {
              output_inst.outputTimingType = 0;
          }
          else
          {
             QMessageBox::information(0, "error", "Output timing type '" +  fields[1] + "'  not supported");
          }
        }
        outputs.push_back(output_inst);
      } // end output
      //////////
      if(fields[0] == "#table"
              && inputReadFlag == false // input has not been read yet - avoid duplication of tables
              )
      {
        pumpseries pumpseries_inst;
        entry entry_inst;

        valueString = in.readLine();
        fields = valueString.split(" ");
        pumpseries_inst.name = fields[0];

        valueString = in.readLine();
        fields = valueString.split(" ");
        pumpseries_inst.numberOfEntries = QString(fields[0]).toInt();
        for (int i = 0; i < pumpseries_inst.numberOfEntries; i++)
        {
          valueString = in.readLine();
          fields = valueString.split(" ");
          entry_inst.time = QString(fields[0]).toDouble();
          entry_inst.value = QString(fields[1]).toDouble();
          pumpseries_inst.entries.push_back(entry_inst);
        }
        pumpseries_vec.push_back(pumpseries_inst);
      }
    } // for
    file.close();
    if (outputs.size() != 2)
         QMessageBox::information(0, "error", "You must provide exactly two output instances");
  } // end file open
}

//////////////////////////////////////////////////////////////////////////////
/// \brief setOutputNodes - fill output[1] with nodes
/// \param _outputNodes
/// \param ndx: 1 must be taken (see restriction above)
///
void CData::setOutputNodes( QVector<outputNode> _outputNodes, int ndx)
{
    outputs[ndx].outputNodes.clear();
    for(int i=0; i < (int)_outputNodes.size(); i++)
        outputs[ndx].outputNodes.push_back(_outputNodes[i]);
}

//////////////////////////////////////////////////////////////////////////////
/// \brief CData::writeData
/// \param outputFile: path and name
///
void CData::writeData(QString outputFile)
{

  QFile file( outputFile );
  if ( file.open(QIODevice::WriteOnly) )
  {
     QTextStream stream( &file );

     stream  << endl << "#aquifer" << endl;
     stream <<  aquifer.transmissivity << " " << aquifer.storativity << endl;

     stream  << endl << "#domain" << endl;
     stream <<  domain.length[0] << " " << domain.length[1] << " ";
     stream <<  domain.resolution[0] << " " << domain.resolution[1] << endl;

     for(int i = 0; i < (int)wells.size(); i++)
     {
       stream  << endl << "#well" << endl;
       stream <<  wells[i].location[0] << " " <<  wells[i].location[1] << " ";
       stream <<  wells[i].pumpingRate << " " << wells[i].pumpseriesName << endl;
     }

     stream  << endl << "#timing intervals" << endl;
     stream << timing.numberOfIntervals << " " <<  timing.end << endl;

     for(int i = 0; i < (int)outputs.size(); i++)
     {
       stream  << endl << "#output" << endl;
       stream <<  outputs[i].outfileName << endl;
       if (outputs[i].outputDistributionType == 0)
       {
         stream <<  "domain" << endl;
       }
       else
       {
         stream <<  "selected nodes" << endl;
         stream <<  outputs[i].outputNodes.size() << endl;
         for(int j = 0; j < (int)outputs[i].outputNodes.size(); j++)
         {
           stream <<  outputs[i].outputNodes[j].x << " " << outputs[i].outputNodes[j].y  << endl;
         }
       }
       stream <<  "times all" << endl;
     } // end for

     for(int i = 0; i < (int)pumpseries_vec.size(); i++)
     {
       stream << endl << "#table" << endl;
       stream <<  pumpseries_vec[i].name << endl;
       stream <<  pumpseries_vec[i].numberOfEntries << endl;
       for (int j=0 ; j < pumpseries_vec[i].numberOfEntries; j++)
       {
         stream <<  pumpseries_vec[i].entries[j].time << " " <<  pumpseries_vec[i].entries[j].value << endl;
       }
     } // end for
     stream  << endl << "#end" << endl;
  } // end file open
  file.close();
}
